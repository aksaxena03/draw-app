# import axios from 'axios';
# import { getExitingShape } from "./http";
# import { HTTP_BACKEND } from '@/config';

# type Point = { x: number; y: number };

# interface BaseShape {
#     type: string;
# }

# interface RectShape extends BaseShape {
#     type: "rect";
#     x: number;
#     y: number;
#     width: number;
#     height: number;
# }

# interface PencilShape extends BaseShape {
#     type: "pencil";
#     points: Point[];
# }

# interface CircleShape extends BaseShape {
#     type: "circle";
#     centerX: number;
#     centerY: number;
#     radius: number;
#     startAngle: number;
#     endingAngle: number;
# }

# interface TextShape extends BaseShape {
#     type: "text";
#     x: number;
#     y: number;
#     text: string;
# }

# type Shape = RectShape | PencilShape | CircleShape | TextShape;

# declare global {
#     interface Window {
#         stage: string;
#         token: string;
#     }
# }

# export class Game {
#     private canvas: HTMLCanvasElement;
#     private ctx: CanvasRenderingContext2D;
#     private socket: WebSocket;
#     private existingShape: Shape[] = [];
#     private roomid: string;
#     private moving = false;
#     private startx = 0;
#     private starty = 0;
#     private activeShape: Shape | null = null;
#     private currentPencil: Point[] | null = null;
#     private scale = 1;
#     private offsetX = 0;
#     private offsetY = 0;
#     private readonly minScale = 0.2;
#     private readonly maxScale = 5;
#     private readonly scaleStep = 0.1;
#     private isPanning = false;
#     private panStartX = 0;
#     private panStartY = 0;
#     private lastOffsetX = 0;
#     private lastOffsetY = 0;
#     private spacePressed = false;

#     constructor(canvas: HTMLCanvasElement, roomid: string) {
#         this.canvas = canvas;
#         this.roomid = roomid;
#         this.ctx = canvas.getContext("2d") as CanvasRenderingContext2D;
#         this.socket = new WebSocket(`${HTTP_BACKEND}/ws/${roomid}`);
        
#         this.init().catch(console.error);
#         this.initHandlers();
#         this.initMouseHandlers();
#     }

#     private async init(): Promise<void> {
#         this.existingShape = await getExitingShape(this.roomid);
#         this.drawExistingShapes();
#     }

#     private drawExistingShapes(): void {
#         this.clearCanvas();
#         for (const shape of this.existingShape) {
#             this.drawShape(shape);
#         }
#     }

#     private drawShape(shape: Shape): void {
#         this.ctx.save();
#         this.ctx.setTransform(this.scale, 0, 0, this.scale, this.offsetX, this.offsetY);
#         this.ctx.strokeStyle = "rgb(255,255,255)";
#         this.ctx.fillStyle = "white";
#         this.ctx.lineWidth = 3;
#         this.ctx.lineCap = 'round';

#         switch (shape.type) {
#             case "rect": {
#                 this.ctx.beginPath();
#                 this.ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
#                 this.ctx.stroke();
#                 break;
#             }
#             case "pencil": {
#                 if (shape.points.length < 2) return;
#                 this.ctx.beginPath();
#                 this.ctx.moveTo(shape.points[0].x, shape.points[0].y);
#                 for (let i = 1; i < shape.points.length; i++) {
#                     this.ctx.lineTo(shape.points[i].x, shape.points[i].y);
#                 }
#                 this.ctx.stroke();
#                 this.ctx.closePath();
#                 break;
#             }
#             case "circle": {
#                 this.ctx.beginPath();
#                 this.ctx.arc(
#                     shape.centerX,
#                     shape.centerY,
#                     Math.abs(shape.radius),
#                     shape.startAngle,
#                     shape.endingAngle
#                 );
#                 this.ctx.stroke();
#                 this.ctx.closePath();
#                 break;
#             }
#             case "text": {
#                 this.ctx.font = "24px Arial";
#                 this.ctx.fillText(shape.text, shape.x, shape.y);
#                 break;
#             }
#         }
#         this.ctx.restore();
#     }

#     private clearCanvas(): void {
#         this.ctx.save();
#         this.ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
#         this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
#         this.ctx.fillStyle = "rgb(0,0,0)";
#         this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
#         this.ctx.restore();
#     }

#     private initHandlers(): void {
#         this.socket.onmessage = (event: MessageEvent) => {
#             const message = JSON.parse(event.data);
#             if (message.type === "chat_shape") {
#                 const { shape } = JSON.parse(message.shape);
#                 this.existingShape.push(shape);
#                 this.drawExistingShapes();
#             }
#         };

#         window.addEventListener('keydown', (e) => {
#             if (e.code === 'Space') this.spacePressed = true;
#         });

#         window.addEventListener('keyup', (e) => {
#             if (e.code === 'Space') this.spacePressed = false;
#         });
#     }

#     private initMouseHandlers(): void {
#         this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
#         this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
#         this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
#         this.canvas.addEventListener('wheel', this.handleWheel.bind(this));
#     }

#     private handleMouseDown(e: MouseEvent): void {
#         if (this.spacePressed) {
#             this.isPanning = true;
#             this.panStartX = e.clientX - this.lastOffsetX;
#             this.panStartY = e.clientY - this.lastOffsetY;
#             return;
#         }

#         this.moving = true;
#         this.startx = e.clientX;
#         this.starty = e.clientY;

#         if (window.stage === "pencil") {
#             this.currentPencil = [{ x: this.startx, y: this.starty }];
#         } else if (window.stage === "text") {
#             const text = prompt("Enter text:") || "";
#             if (text.trim() !== "") {
#                 const shape: TextShape = {
#                     type: "text",
#                     x: this.startx,
#                     y: this.starty,
#                     text
#                 };
#                 this.addShape(shape);
#             }
#             this.moving = false;
#         }
#     }

#     private handleMouseMove(e: MouseEvent): void {
#         if (this.isPanning) {
#             this.offsetX = e.clientX - this.panStartX;
#             this.offsetY = e.clientY - this.panStartY;
#             this.lastOffsetX = this.offsetX;
#             this.lastOffsetY = this.offsetY;
#             this.drawExistingShapes();
#             return;
#         }

#         if (!this.moving) return;

#         const endX = e.clientX;
#         const endY = e.clientY;
#         const width = endX - this.startx;
#         const height = endY - this.starty;

#         this.drawExistingShapes();

#         if (window.stage === "pencil" && this.currentPencil) {
#             this.currentPencil.push({ x: endX, y: endY });
#             this.drawShape({ type: "pencil", points: this.currentPencil });
#         } else if (window.stage === "rect") {
#             this.drawShape({
#                 type: "rect",
#                 x: this.startx,
#                 y: this.starty,
#                 width,
#                 height
#             });
#         } else if (window.stage === "circle") {
#             const radius = Math.max(width, height) / 2;
#             this.drawShape({
#                 type: "circle",
#                 centerX: this.startx + width / 2,
#                 centerY: this.starty + height / 2,
#                 radius,
#                 startAngle: 0,
#                 endingAngle: Math.PI * 2
#             });
#         }
#     }

#     private async handleMouseUp(e: MouseEvent): Promise<void> {
#         if (this.isPanning) {
#             this.isPanning = false;
#             return;
#         }

#         if (!this.moving) return;
#         this.moving = false;

#         const width = e.clientX - this.startx;
#         const height = e.clientY - this.starty;

#         let shape: Shape | null = null;

#         if (window.stage === "rect") {
#             shape = {
#                 type: "rect",
#                 x: this.startx,
#                 y: this.starty,
#                 width,
#                 height
#             };
#         } else if (window.stage === "pencil" && this.currentPencil) {
#             shape = {
#                 type: "pencil",
#                 points: this.currentPencil
#             };
#         } else if (window.stage === "circle") {
#             shape = {
#                 type: "circle",
#                 radius: Math.max(width, height) / 2,
#                 centerX: this.startx + width / 2,
#                 centerY: this.starty + height / 2,
#                 startAngle: 0,
#                 endingAngle: Math.PI * 2
#             };
#         }

#         if (shape) {
#             await this.addShape(shape);
#         }

#         this.currentPencil = null;
#     }

#     private handleWheel(e: WheelEvent): void {
#         e.preventDefault();
#         const delta = e.deltaY > 0 ? -this.scaleStep : this.scaleStep;
#         const newScale = this.scale + delta;

#         if (newScale >= this.minScale && newScale <= this.maxScale) {
#             // Zoom to cursor
#             const rect = this.canvas.getBoundingClientRect();
#             const mouseX = (e.clientX - rect.left - this.offsetX) / this.scale;
#             const mouseY = (e.clientY - rect.top - this.offsetY) / this.scale;

#             this.scale = newScale;
#             this.offsetX = e.clientX - rect.left - mouseX * this.scale;
#             this.offsetY = e.clientY - rect.top - mouseY * this.scale;

#             this.drawExistingShapes();
#         }
#     }

#     private async addShape(shape: Shape): Promise<void> {
#         this.existingShape.push(shape);
#         this.socket.send(JSON.stringify({
#             type: "chat_shape",
#             shape: JSON.stringify({ shape }),
#             roomid: this.roomid
#         }));

#         await axios.post(`${HTTP_BACKEND}/room/shape/${this.roomid}`,
#             { shape },
#             { headers: { authorization: window.token } }
#         );
#     }

#     public undo(): void {
#         if (this.existingShape.length > 0) {
#             this.existingShape.pop();
#             this.drawExistingShapes();
#         }
#     }

#     public zoomIn(): void {
#         const rect = this.canvas.getBoundingClientRect();
#         const centerX = (rect.width / 2 - this.offsetX) / this.scale;
#         const centerY = (rect.height / 2 - this.offsetY) / this.scale;
#         const newScale = Math.min(this.maxScale, this.scale + this.scaleStep);

#         this.offsetX -= (centerX * newScale - centerX * this.scale);
#         this.offsetY -= (centerY * newScale - centerY * this.scale);
#         this.scale = newScale;

#         this.drawExistingShapes();
#     }

#     public zoomOut(): void {
#         const rect = this.canvas.getBoundingClientRect();
#         const centerX = (rect.width / 2 - this.offsetX) / this.scale;
#         const centerY = (rect.height / 2 - this.offsetY) / this.scale;
#         const newScale = Math.max(this.minScale, this.scale - this.scaleStep);

#         this.offsetX -= (centerX * newScale - centerX * this.scale);
#         this.offsetY -= (centerY * newScale - centerY * this.scale);
#         this.scale = newScale;

#         this.drawExistingShapes();
#     }

#     public resetView(): void {
#         this.scale = 1;
#         this.offsetX = 0;
#         this.offsetY = 0;
#         this.drawExistingShapes();
#     }

#     public getShapeCount(): number {
#         return this.existingShape.length;
#     }
# }
